<!DOCTYPE html><html lang="zh-TW"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="  OpenGL教學.02 創建窗體並渲染三角  "><meta name="keywords" content="OpenGL"><meta name="author" content="鹹魚蘋果喵站長"><meta name="copyright" content="鹹魚蘋果喵站長"><title>  OpenGL教學.02 創建窗體並渲染三角   | 蘋果喵的後花園</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '已成功複製',
    error: '複製失敗',
    noSupport: '無法在不支援的瀏覽器上快速複製'
  }
} </script></head><body><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/445b35e506a12018c49b3ee77ac0af0e"></div><div class="author-info__name text-center">鹹魚蘋果喵站長</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">標籤</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">類別</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Friend Links</div><a class="author-info-links__name text-center" href="https://kurumi.ink">ZeroSimonKing | 西紅柿炒雞蛋</a><a class="author-info-links__name text-center" href="https://nekohome.moenya.cat">NekoHome 莫妮婭的喵窩</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/appleneko2001/appleneko2001.github.io/master/media/Header.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">蘋果喵的後花園</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">  OpenGL教學.02 創建窗體並渲染三角  </div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/OpenGL/">OpenGL</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p><del>摸魚過度偷懶了 甚至差點忘記補坑，，，（不是）</del><br> <del>更新更過半年後（大草）</del><br> <del>甚至都不想寫Blog了 隨意找個理由逃避（呃呃）</del></p>
</blockquote>
<p>上一次我們提到了什麼是OpenGL 開始之前我們先需要明白如何創建一個OpenGL工作區 也就是用於顯示畫面的窗體</p>
<h3 id="使用OpenGL-Core模式渲染畫面"><a href="#使用OpenGL-Core模式渲染畫面" class="headerlink" title="使用OpenGL Core模式渲染畫面"></a>使用OpenGL Core模式渲染畫面</h3><h4 id="重要"><a href="#重要" class="headerlink" title="!! 重要 !!"></a>!! 重要 !!</h4><p>在開始之前請確認是否準備好下面的道具：</p>
<ul>
<li>Visual Studio (代碼編輯器 也可以使用備選SharpDevelop或者使用自己習慣用的IDE Notepad也可以的說(如果是禿頭君))</li>
<li>OpenTK (用於使用OpenGL的指令，創建窗體等 獲得方式只能是透過NuGet, 不過有一些方法可以解包出裡面的Library檔案出來 <a href="https://www.nuget.org/packages/OpenTK/" target="_blank" rel="noopener">NuGet包下載</a>)</li>
<li>需要最基本的C#程式語言知識 (雖然大部分情況下鹹魚會加很多註釋 但是就算是這樣還請大家先去學習C#程式語言, 建議)</li>
<li>耐心 (沒有耐心只會讓一切亂掉)</li>
</ul>
<h3 id="創建窗體"><a href="#創建窗體" class="headerlink" title="創建窗體"></a>創建窗體</h3><p>在使用所有OpenGL指令之前 需要創建用於工作用的區域 也就是OpenGL窗體 如果沒有這個窗體 其實是不會在畫面上出現任何東西的<br>在.Net Framework渲染OpenGL或者創建窗體可以用一種不錯的方式完成: OpenTK工具庫</p>
<p>OpenTK工具庫是一個包括了OpenAL, OpenGL和提供了部分功能擴充的功能庫 並且附帶類似GLM的數學指令 (Vector2, Matrix等) 該功能庫允許使用C#和Visual Basic代碼語言進行創建依賴這個功能庫的物件和指令 也允許大部分平台的運作 (比如除了Windows以外還有Linux, MacOS等 不過需要用到Mono作為dotNet運作環境)</p>
<p>首先我們這裡建立專案 (這裡鹹魚使用的是Visual Studio 2019, 不過基本上都是差不多一樣的 比如SharpDevelop的操作也跟Visual Studio比較相似)<br><img src="/20200224234039142/20200225125151771.png" alt></p>
<p><img src="/20200224234039142/20200225125557295.png" alt></p>
<p>建立專案後 我們需要先去到NuGet套件管理員得到OpenTK 先選擇一個專案 然後選擇”管理 NuGet 套件” 選擇”瀏覽” 在搜尋區域輸入”OpenTK” 找到下面的套件並選擇安裝<br><img src="/20200224234039142/20200225044559821.png" alt><br>安裝過後 在”參考”處會多出一個OpenTK 這就表示說明我們已經成功取得OpenTK工具庫 接下來我們可以開始使用這個工具庫使用OpenGL的功能<br><img src="/20200224234039142/20200225045017284.png" alt><br>然後我們在專案中加入一個C#代碼檔案 用於區分哪個代碼是用於建立OpenGL工作區的 哪個是用於開始運作的入口代碼</p>
<p>下面我們寫一段非常簡單的代碼進行創建窗體 (非常簡單 一點難度也沒有)<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GlWindow.cs 檔案</span></span><br><span class="line"><span class="keyword">using</span> System; </span><br><span class="line"><span class="keyword">using</span> OpenTK; <span class="comment">//GameWindow類</span></span><br><span class="line"><span class="keyword">using</span> OpenTK.Input; <span class="comment">//鍵盤滑鼠事件交互</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GlWindow</span> : <span class="title">GameWindow</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//將GlWindow類封裝成GameWindow 這樣我們就成功建立</span></span><br><span class="line">        <span class="comment">//OpenGL的工作區了 不光如此還附帶鍵盤與滑鼠的交互處理</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnKeyDown</span>(<span class="params">KeyboardKeyEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//這個地方用於執行鍵盤按鍵按下的交互 如果需要處理比如Esc按下</span></span><br><span class="line">            <span class="comment">//就會完全關閉的功能 可以在這裡實作</span></span><br><span class="line">            <span class="keyword">if</span> (e.Key == Key.Escape) <span class="comment">//如果用戶按下Esc</span></span><br><span class="line">                Exit(); <span class="comment">//關閉OpenGL工作區 停止所有迴圈</span></span><br><span class="line">            <span class="keyword">base</span>.OnKeyDown(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdateFrame</span>(<span class="params">FrameEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//這個地方用於執行一次迴圈 與處理畫面沒有太多關係</span></span><br><span class="line">            <span class="comment">//但是用於處理物件的動態更新 比如物件位移, 旋轉等</span></span><br><span class="line">            <span class="keyword">base</span>.OnUpdateFrame(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRenderFrame</span>(<span class="params">FrameEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//這個地方用於執行畫面處理迴圈 非常建議將跟OpenGL</span></span><br><span class="line">            <span class="comment">//有關係的代碼寫在這裡 比如GL.ClearColor(0,0,0,0)這種</span></span><br><span class="line">            <span class="keyword">base</span>.OnRenderFrame(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Program.cs 檔案</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) <span class="comment">//程式啟動入口 在這裡開始運作代碼</span></span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">using</span>(GlWindow window = <span class="keyword">new</span> GlWindow()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//暫時性建立GlWindow物件 離開這一段代碼之後</span></span><br><span class="line">                <span class="comment">//物件會自己清理並不再可用 </span></span><br><span class="line">                window.Run(); <span class="comment">//啟動OpenGL工作區 啟動所有事件迴圈</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果需要限制事件迴圈的頻率 可以使用 window.Run(30)</span></span><br><span class="line">                <span class="comment">//將畫面處理和物件動態更新迴圈控制在30次一秒 又或者 </span></span><br><span class="line">                <span class="comment">//可以使用這個 window.Run(30, 60) 將物件動態更新控制</span></span><br><span class="line">                <span class="comment">//在30次一秒 而畫面處理將控制在60次一秒</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//離開上面一段代碼之後 到達這裡將會停止程式運作並關閉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其實在GlWindow物件那一段鹹魚把沒有必要的東西給去掉了 比如在按鍵放開後的事件, OpenGL工作區載入之前的準備事件等 如果有必要後期可能會提及 這裡先讓大家明白 用OpenTK建立OpenGL工作區其實特別簡單 不需要寫太多雜亂的代碼 完成輸入這些代碼 (大部分情況下大家肯定是有在用複製粘貼的 不管怎樣都可以) 後我們按下 F5 啟動這個程式 會出現下面的窗體<br><img src="/20200224234039142/20200225052419917.png" alt><br>出現窗體後 表示我們成功的第一次啟動OpenGL工作區了. 接下來我們用這個工作區繪製一個三角物件</p>
<h3 id="繪製簡單的三角型"><a href="#繪製簡單的三角型" class="headerlink" title="繪製簡單的三角型"></a>繪製簡單的三角型</h3><p>繪製三角之前 我們需要明白OpenGL是怎麼畫出來三角物件的<br>OpenGL Core的畫面處理過程是先處理數據 把數據裝入到我們的頂點染色器 (Vertex Shader) 二次轉換後把輸入裝入到片段染色器 (Fragment Shader) 在這裡OpenGL就會對著點位加色 就好像我們用頂點染色器選擇了一片區域 然後片段染色器就會在選擇的區域上加色一樣 所以接下來我們需要先準備一些三角的繪圖座標 這裡我們先使用立體的三角繪圖座標組 當然也可以使用平面的三角繪圖座標組 如果這樣的話我們需要對頂點染色器稍作修改</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vector3[] triangle_3d = &#123; <span class="comment">//立體三角形狀數據</span></span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.5f</span>),</span><br><span class="line">    <span class="keyword">new</span> Vector3( <span class="number">0.4f</span>, <span class="number">-0.4f</span>, <span class="number">0.2f</span>),</span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">-0.1f</span>,  <span class="number">0.5f</span>, <span class="number">0.3f</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Vector2[] triangle_2d = &#123; <span class="comment">// 平面三角形狀數據</span></span><br><span class="line">     <span class="keyword">new</span> Vector2(<span class="number">-0.5f</span>, <span class="number">-0.4f</span>),</span><br><span class="line">     <span class="keyword">new</span> Vector2(<span class="number">-0.6f</span>, <span class="number">-0.3f</span>),</span><br><span class="line">     <span class="keyword">new</span> Vector2(<span class="number">0.05f</span>,  <span class="number">0.6f</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了上面的點位數據 就可以編寫一個簡單的染色器代碼了 下面我們稍微研究一下非常簡單的染色器代碼</p>
<h5 id="頂點染色器代碼"><a href="#頂點染色器代碼" class="headerlink" title="頂點染色器代碼"></a>頂點染色器代碼</h5><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core   //表示這個加色器的GLSL最低要求版本 染色器要求第一行選定版本</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>)<span class="keyword">in</span> <span class="type">vec3</span> vertex; <span class="comment">//數據輸入屬性, 在這裡我們</span></span><br><span class="line"><span class="comment">//灌入上面的形狀數據 要求立體形狀 而不是平面形狀版, 如果要平面形狀</span></span><br><span class="line"><span class="comment">//可以把vec3改成vec2 下面也要稍作修改</span></span><br><span class="line"><span class="type">void</span> main() &#123; <span class="comment">//加色器入口處</span></span><br><span class="line"><span class="built_in">gl_Position</span> = <span class="type">vec4</span>(vertex, <span class="number">1.0</span>); <span class="comment">//讓OpenGL圈選要加色的區域 選擇之前</span></span><br><span class="line"><span class="comment">//需要先過一個四維座標封裝 把立體形狀數據套入 如果是平面形狀 需要把</span></span><br><span class="line"><span class="comment">//(vertex, 1.0)改成(vertex, 0.0, 1.0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="片段染色器代碼"><a href="#片段染色器代碼" class="headerlink" title="片段染色器代碼"></a>片段染色器代碼</h5><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core   //跟頂點染色器一樣 第一行選擇GLSL最低要求版本</span></span><br><span class="line"><span class="type">void</span> main() &#123; <span class="comment">//加色器入口處 </span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">0.5</span>,<span class="number">0.7</span>,<span class="number">1.0</span>,<span class="number">1.0</span>); <span class="comment">//讓OpenGL使用天藍色加色</span></span><br><span class="line">    <span class="comment">//vec4(r, g, b, a) 其中r位是紅色, g位是藍色, b位是藍色 a位是阿爾法</span></span><br><span class="line">    <span class="comment">//阿爾法指數用於制定物件的半透明 如果是1.0就是完全不透明 如果是0.0是隱藏</span></span><br><span class="line">    <span class="comment">//相對的 r位,g位和b位的指數在0.0到1.0之間 如果要使用255最大可以改成下面</span></span><br><span class="line">    <span class="comment">//的形式:</span></span><br><span class="line">    <span class="comment">//(127/255.0, 180/255.0, 255/255.0 255/255.0)這樣系統將自動把指數轉換</span></span><br><span class="line">    <span class="comment">//成上面的形式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據上面的代碼分析 我們能明白一個事情 編寫染色器的難度並不高 而且GLSL語言規範是類似C語言 但又有點C++的樣子 這個我們在後期再提及. 染色器的準備和使用方式如下:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> vert = <span class="comment">//準備頂點染色器代碼</span></span><br><span class="line"><span class="string">@"#version 330 core</span></span><br><span class="line"><span class="string">layout (location = 0)in vec3 vertex;</span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">gl_Position = vec4(vertex, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line"><span class="keyword">string</span> frag = <span class="comment">//準備片段染色器代碼</span></span><br><span class="line"><span class="string">@"#version 330 core</span></span><br><span class="line"><span class="string">out vec4 FragColor;</span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">FragColor = vec4(0.5,0.7,1.0,1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line"><span class="keyword">int</span> v = GL.CreateShader(ShaderType.VertexShader),</span><br><span class="line">    f = GL.CreateShader(ShaderType.FragmentShader);</span><br><span class="line"><span class="comment">//準備兩個空的OpenGL染色器 一個是頂點染色器 還有一個是片段染色器</span></span><br><span class="line">GL.ShaderSource(v, vert); <span class="comment">//把頂點染色器的代碼輸入到剛剛</span></span><br><span class="line"><span class="comment">//準備好的空的頂點染色器的地方 下面的片段染色器的操作幾乎一樣</span></span><br><span class="line">GL.ShaderSource(f, frag);</span><br><span class="line">GL.CompileShader(v); <span class="comment">//把頂點染色器的代碼轉變成可執行的二進制</span></span><br><span class="line"><span class="comment">//數據, 下面的片段染色器也是一樣的操作</span></span><br><span class="line">GL.CompileShader(f);</span><br><span class="line">program = GL.CreateProgram(); <span class="comment">//建立一個要把兩個染色器合併的區域</span></span><br><span class="line">GL.AttachShader(program, v); <span class="comment">//把頂點染色器的二進制輸入灌入</span></span><br><span class="line"><span class="comment">//下面的片段染色器 也是一樣這麼做</span></span><br><span class="line">GL.AttachShader(program, f);</span><br><span class="line"><span class="comment">//最後再把兩個染色器聯繫起來 變成一個染色器的完整體</span></span><br><span class="line">GL.LinkProgram(program);</span><br><span class="line"><span class="comment">//聯繫起來後 上面的v跟f已經沒有用了 可以清理掉用於釋出顯示卡的空間</span></span><br><span class="line">GL.DeleteShader(v);</span><br><span class="line">GL.DeleteShader(f);</span><br><span class="line">GL.UseProgram(program); <span class="comment">//使用染色器</span></span><br></pre></td></tr></table></figure></p>
<p>根據上面的代碼分析 我們需要準備一個暫時的區域用於把染色器的代碼編譯成二進制數據 然後再用這些數據灌入到染色器程式的區域 最後將兩個染色器數據聯繫起來 變成最後可以正常運作的染色器程式單元 過程非常類似編譯C/C++的程式 不過也比較簡單 只不過佔用的行數比較多 可以把這些代碼封裝成自動化函數.</p>
<p>光有染色器跟數據還不夠 下面我們需要瞭解一下VBO (頂點暫存對象)</p>
<h4 id="Vertex-Buffer-Object-VBO-頂點暫存對象"><a href="#Vertex-Buffer-Object-VBO-頂點暫存對象" class="headerlink" title="Vertex Buffer Object (VBO, 頂點暫存對象)"></a>Vertex Buffer Object (VBO, 頂點暫存對象)</h4><p>這個東西是允許我們將數據暫時存入到的地方 也就是我們可以把上面的座標數據存入的地方 使用方式是類似下面的代碼<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer = GL.GenBuffer(); <span class="comment">//讓OpenGL建立一片用於存入數據的區域</span></span><br><span class="line">GL.BindBuffer(BufferTarget.ArrayBuffer, buffer); <span class="comment">//選擇要使用的區域</span></span><br><span class="line">GL.BufferData(BufferTarget.ArrayBuffer, <span class="comment">// 將數據存入到當前選擇的區域</span></span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span> * <span class="number">3</span>, <span class="comment">// 數據大小 如果是三組數據 (三個單精度數據) </span></span><br><span class="line">    <span class="comment">//可以使用sizeof(float) 再乘上3 然後因為是三組數據 需要再乘上3</span></span><br><span class="line">    triangle_3d, <span class="comment">//選擇頂點數據</span></span><br><span class="line">    BufferUsageHint.StaticDraw); <span class="comment">//標記用途 不會對效能有太大的影響</span></span><br></pre></td></tr></table></figure></p>
<p>根據上面的部分代碼分析 能看到想要存入數據並不是特別簡單 我們需要先準備出來要存入數據的地方 然後選擇一個區域 再把數據存入 差不多每次操作還要說這個暫存區域是做什麼的(BufferTarget.ArrayBuffer, 這裡有兩種我們知道的 一個是ArrayBuffer 還有一個是ElementArrayBuffer 第二個我們稍作解釋) 存入數據是需要數據的本身長度乘上數據數量的 就好像我們放東西需要知道我們放的東西有多大 不知道大小的情況下就放入了就會沒辦法放下 不過難度並不是特別高 如果想要知道數據的大小 只需要前面先加一個sizeof(數據類型) * 數量.<br>我們可以使用下面的方式代替上面的形式 </p>
<blockquote>
<p>sizeof(數據類型) * 數量 * 數據組數量<br>比如說我們有四個Vector3的數據 就會是下面的形式:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span> * <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>當然也可以變成自動化 比如這樣 :<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span> * data.Length</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>現在我們至少有了VBO, 染色器和座標數據 但是還差一個東西 是需要指示OpenGL如何正確使用這個資料的東西 如果還記得我們剛剛在頂點染色器中有一個location = 0的東西 這個東西是用於表示屬性的ID的 因為這些東西需要用在頂點屬性指針上 頂點屬性指針的用法是這樣的:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GL.VertexAttribPointer(屬性ID, Vec大小, 數據類型, 法線化, 步數(不知道stride中文叫什麼,,), 偏移);</span><br></pre></td></tr></table></figure></p>
<p>按照上面的用法 我們需要先知道屬性的位置 屬性的位置可以自己定義也可以用GL.GetAttribLocation獲得屬性的ID, 除此之外我們需要向量數量 比如說對應的屬性是vec3類型的 那麼就寫成3<br>數據類型的話 如果沒有雙精度 大部分情況下建議用 VertexAttribPointerType.Float(單精度類型)<br>法線化我們用false 如果用true的話數據將會被限制在0跟1這一段距離之間<br>stride是指定數據長度 如果我們需要用到三維向量數據的話 那麼就是sizeof(float) * 3,  最後的偏移參數是用於制定stride開始的地方 因為我們除了座標數據外沒有其他的東西了 那麼只需要設定為0就好 最終的樣子是這樣的:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GL.VertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, VertexAttribPointerType.Float, <span class="literal">false</span>, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>指定完成後 再差一個啟用指令就可以正常運作了:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GL.EnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>這個指令是用於啟動頂點屬性陣列的輸入 如果沒有這個指令 數據輸入不進去 也就不會出現任何東西</p>
<p>然後我們來最後了解一個指令 繪圖和傳遞數據到畫面上<br>繪圖指令的使用方式是這樣的:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GL.DrawArrays(形狀類型, 開始指針, 數量);</span><br></pre></td></tr></table></figure></p>
<p>形狀類型可以用線狀, 三角狀, 四角狀, 扇片等 但是大部分情況下建議用三角狀<br>開始指針是根據要從哪個數據位置開始 因為我們的三角數據只有三個頂點, 不能少於三個 不然沒辦法繪畫三角 因此我們這裡用0, 最後的參數是數量 是指需要用多少個頂點數據 因為至少要三個頂點 而且我們最多也只有三個頂點 因此這裡數量我們用3<br>根據剛才的分析 我們得出下面的結果:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GL.DrawArrays(PrimitiveType.Triangles, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>最後 我們需要用到這個指令就好了:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SwapBuffers(); <span class="comment">//把所有圖像數據傳輸到畫面上</span></span><br></pre></td></tr></table></figure></p>
<p>使用上面的指令 將所有圖像數據傳遞到畫面中 呈現這些圖像</p>
<p>把這些東西拼起來 最終的效果和代碼就像下面這樣:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">GlWindow.cs 檔案</span><br><span class="line"><span class="keyword">using</span> System; </span><br><span class="line"><span class="keyword">using</span> OpenTK; <span class="comment">//GameWindow類</span></span><br><span class="line"><span class="keyword">using</span> OpenTK.Input; <span class="comment">//鍵盤滑鼠事件交互</span></span><br><span class="line"><span class="keyword">using</span> OpenTK.Graphics.OpenGL; <span class="comment">//使用OpenGL功能</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GlWindow</span> : <span class="title">GameWindow</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> program = <span class="number">0</span>; <span class="comment">//染色器程式ID </span></span><br><span class="line">        <span class="keyword">int</span> buffer = <span class="number">0</span>; <span class="comment">//暫存區域ID</span></span><br><span class="line">        Vector3[] triangle_3d = &#123; <span class="comment">//立體三角形狀數據</span></span><br><span class="line">           <span class="keyword">new</span> Vector3 (<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>),</span><br><span class="line">           <span class="keyword">new</span> Vector3 ( <span class="number">0.4f</span> , <span class="number">-0.4f</span>, <span class="number">0.0f</span>),</span><br><span class="line">           <span class="keyword">new</span> Vector3 (<span class="number">-0.1f</span>,  <span class="number">0.5f</span> , <span class="number">0.0f</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnLoad</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            GL.Enable(EnableCap.DepthTest);</span><br><span class="line">            <span class="keyword">string</span> vert = <span class="comment">//頂點染色器代碼</span></span><br><span class="line"><span class="string">@"#version 330 core</span></span><br><span class="line"><span class="string">layout (location = 0)in vec3 vertex;</span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">gl_Position = vec4(vertex, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line">            <span class="keyword">string</span> frag = <span class="comment">//片段染色器代碼</span></span><br><span class="line"><span class="string">@"#version 330 core</span></span><br><span class="line"><span class="string">out vec4 FragColor;</span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">FragColor = vec4(0.5,0.7,1.0,1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line">            <span class="keyword">int</span> v = GL.CreateShader(ShaderType.VertexShader),</span><br><span class="line">                f = GL.CreateShader(ShaderType.FragmentShader);</span><br><span class="line">            GL.ShaderSource(v, vert);</span><br><span class="line">            GL.ShaderSource(f, frag);</span><br><span class="line">            GL.CompileShader(v);</span><br><span class="line">            GL.CompileShader(f);</span><br><span class="line">            program = GL.CreateProgram(); </span><br><span class="line">            GL.AttachShader(program, v);</span><br><span class="line">            GL.AttachShader(program, f);</span><br><span class="line">            GL.LinkProgram(program);</span><br><span class="line">            GL.DeleteShader(v); GL.DeleteShader(f);</span><br><span class="line"></span><br><span class="line">            buffer = GL.GenBuffer();</span><br><span class="line">            GL.BindBuffer(BufferTarget.ArrayBuffer, buffer);</span><br><span class="line">            GL.BufferData(BufferTarget.ArrayBuffer,</span><br><span class="line">                <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span> * triangle_3d.Length, </span><br><span class="line">                triangle_3d, BufferUsageHint.StaticDraw); </span><br><span class="line">            GL.VertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, VertexAttribPointerType.Float, <span class="literal">false</span>, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), <span class="number">0</span>);</span><br><span class="line">            GL.EnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">base</span>.OnLoad(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnKeyDown</span>(<span class="params">KeyboardKeyEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.Key == Key.Escape) <span class="comment">//如果用戶按下Esc</span></span><br><span class="line">                Exit(); <span class="comment">//關閉OpenGL工作區 停止所有迴圈</span></span><br><span class="line">            <span class="keyword">base</span>.OnKeyDown(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdateFrame</span>(<span class="params">FrameEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;  <span class="keyword">base</span>.OnUpdateFrame(e); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRenderFrame</span>(<span class="params">FrameEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;            </span><br><span class="line">            GL.UseProgram(program); <span class="comment">//使用染色器程式</span></span><br><span class="line">            GL.BindBuffer(BufferTarget.ArrayBuffer, buffer); <span class="comment">//選擇要使用的頂點數據</span></span><br><span class="line">            GL.DrawArrays(PrimitiveType.Triangles, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">//畫出這些數據 轉變成圖像數據</span></span><br><span class="line">            SwapBuffers(); <span class="comment">//傳遞數據到畫面 呈現這些圖像</span></span><br><span class="line">            <span class="keyword">base</span>.OnRenderFrame(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最終效果像下面這樣:<br><img src="/20200224234039142/20200225080126932.png" alt><br>雖然畫出來了 但是閃的很厲害 因為我們需要在開始之前清理舊的數據重新再畫一次<br>這裡我們可以用到下面兩段代碼 來完成這些功能:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);</span><br><span class="line"><span class="comment">//清除顏色數據和深度數據</span></span><br><span class="line">GL.ClearColor(<span class="number">0.1f</span>, <span class="number">0.12f</span>, <span class="number">0.15f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">//把背板顏色改成黑藍色(超黑的有沒有 黑到看不到藍了XDD</span></span><br></pre></td></tr></table></figure></p>
<p>把這兩個代碼放在GL.UseProgram(program);的前面 最後出來的結果就像下面這樣:<br><img src="/20200224234039142/20200225081828535.png" alt><br>成功畫出來了 也沒有閃了 最終代碼我會放出來 放在Github上</p>
<p>雖然 畫出來了我們需要的形狀 但是畫出來的樣子不太正常 因為出來的座標位置都是受到法線化設備座標(NDC, 完全名稱是Normalized Device Coordinates)的限制 沒有辦法根據窗體大小而正常變化物件 因此在這個教程過後我們將用4x4的陣列 (Matrix) 改正這個問題.  </p>
<p>上面沒有提到的ElementArrayBuffer, 多出來很多的準備事件和指令自動化 我們會再找個機會把這些都提及到 因為已經咕了太久了 而且表達能力也不是特別好 非常著急想把坑補完 如果覺得哪裡不太正常歡迎來指正 鹹魚先溜了 還要修一下留言系統,,, 還要把Blog版面更新一下 天啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊(自爆)</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OpenGL/">OpenGL</a></div><div class="social-share" data-disabled="google,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2019/07/14/OpenGL教學-01/"><span>  OpenGL教學.01 什麼是OpenGL以及他的用處  </span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'c782d49c99347d6a542c',
  clientSecret: 'efd8fbe6234e80cc0262ad57b0f9f1e1de349d63',
  repo: 'appleneko2001.github.io',
  owner: 'appleneko2001',
  admin: 'appleneko2001',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-TW'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/appleneko2001/appleneko2001.github.io/master/media/Header_072019.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By 鹹魚蘋果喵站長</div><div class="framework-info"><span>Powered by </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Using theme </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a><span class="footer-separator">|</span><span>Theme modification by </span><a href="https://github.com/appleneko2001"><span>appleneko2001</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://kit.fontawesome.com/3531337261.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i></body></html>